<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.74.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/categories/index.xml" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
      <link href="/categories/index.xml" rel="feed" type="application/rss+xml" title="My New Hugo Site" />
      
    
    
    <meta property="og:title" content="Categories" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/categories/" />
<meta property="og:updated_time" content="2019-08-02T14:24:00+00:00" />
<meta itemprop="name" content="Categories">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Categories"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Categories
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/categories/development" class="link blue hover-black">
            Category: development
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-02-docker-concept-analogy/" class="link black dim">
        Docker几个概念的类比
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Docker的官方网站上列出了Docker的几个核心概念：image, container,service,stack,swarm
为了便于理解将这几个概念和程序员熟悉的编程日常做一个类比：
 image 就是类似于代码中的类class 它声明了这个class应有的属性和功能 container 就是class的实例化instance 或者叫 对象object service 就像是class的调用，怎么初始化，以及生成几个实例 stack 就像一个app,它实际就是一组service swarm 就是可以为app提供分布式部署的工具,可以把app部署到多个服务器上  这样类比不是很精确，只是为了建立一个直观的docker概念印象
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-01-jwt/" class="link black dim">
        JWT概述
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JWT是什么 现在BS/CS常见的用户认证方式中比较常见的是cookie&amp;session 以及 token ,jwt就是token 的一种，一般token 使用的方式就是在请求的url 加上token 字符串或者放到http header 里面，jwt 也是这样 标准文档
jwt 呈现出的方式是一个紧凑且url safe的字符串，和一般token一样，jwt也有一套生成的规则。 jwt 的token 看起来是这样样子的 (JWS形式 ，jwt 还有另一种形式JWE)
 xxxx.yyyy.zzzz Header.Payload.Signature
三部分都通过base64 safe url encode 处理
 ![WX20190701-114948]({{ site.url }}/assets/img/WX20190701-114948.png)
图片来源于 https://jwt.io/ 截图 这个截图Web界面里面的原json 字符有格式化的显示，实际base64urlencode 的时候字符串里有什么都会被encode 包括换行空格，空格换行不影响json 的encode 和 decode ，这个实际上和jwt已经没关系了
![WX20190701-121119]({{ site.url }}/assets/img/WX20190701-121119.png)
关于header 和 playload 字段中的意义和signature的方式都可以看标准文档，至于jwt想怎么使用 和其他token没什么差别，放到url或者http header（既然是个字符串也可以放到cookie里 ,但是jwt就是为了解决cookie不能跨域的问题的，这样做又兜回去了）都可以，工程上的决定看开发者
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/categories/javascript" class="link blue hover-black">
            Category: javascript
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-06-24-redux-and-react/" class="link black dim">
        Redux和React的关系
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Redux是什么  Redux is a predictable state container for JavaScript apps. 官方说法
  Redux 是一个可预测的JS APP的状态容器，独立于React 以及其他框架或者库。 Redux 是一个唯一的状态仓库，也就是在一个APP里面只能有一个 仓库里面的状态值只读 修改状态值只能通过Action来修改，由Action来告诉Redux 修改哪一个值以及怎么修改， 这个Action实际经常用用一个function来获得，由两个数据：不同类型的值 Action 需要指明不同的类型 以及 这个类型的值 ![action]({{ site.url }}/assets/img/p0244pro01.jpg) 知道了怎么修改 ，也有需要有人来执行这个操作，这个人就是Reducer根据和action约定的不同的规则来做不同的修改
![reducer]({{ site.url }}/assets/img/p0245pro02.jpg) 已经知道了怎么做，那么到底怎么实施的呢？var store = Redux.createStore(favoriteColors);  用reducer作为一个初始化参数才创建仓库，以及有个入口方法来接收action
store.dispatch(addColor(&quot;blue&quot;)); store.dispatch(addColor(&quot;yellow&quot;)); store.dispatch(addColor(&quot;green&quot;)); store.dispatch(addColor(&quot;red&quot;)); 怎么和React建立联系 Redux既然是独立于React的，那么要和React一起使用，必然需要一个&quot;中间件&quot;来沟通，这个&quot;中间件&rdquo; 就是redux-react 库。
Redux 本身有读取和写入状态库的操作，那么我们也要让React具有相同的能力
 Provider component 提供了让React读取Redux Store的能力
![provider]({{ site.url }}/assets/img/p0260pro02.jpg)
那么Provider 是怎么实现让React各层可以访问redux store 的呢？ 这个全靠React本身的能力Context, Context 提供了一种向整个component tree 传递props的方式，这种方式避免了每层都手动传递 Redux修改Store的能力，是通过dispatch来接收action, 我们也要让React和这个能力做一个捆绑链接，这个需要 Connect Component 来实现  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/categories/operatesystem" class="link blue hover-black">
            Category: operatesystem
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-08-02-event-based-concurrency/" class="link black dim">
        基于事件的并发
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      基础 之前一直用thread 来写并发的程序，但是在一些其他类型的并发程序也是用基于事件的方式，比如GUI程序以及http server 类的程序。
基于事件的并发主要解决两个问题：
 anaging concurrency correctly in multi-threaded applications can be challenging in a multi-threaded application, the developer has little or no control over what is schedule at a given moment in time  Event-based Concurrency 的简单定义：
 you simply wait for something (i.e., an “event”) to occur; when it does, you check what type of event it is and do the small amount of work it requires (which may include issuing I/O requests, or scheduling other events for future handling, etc.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-26-threads-semaphore/" class="link black dim">
        Semaphores 信号量
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Dijkstra 和他的同事研究完 lock 和 condition variable 发明了信号量 semaphore。 哪哪都能看到大佬的名字。
信号量能以单个机制解决所有相关的多线程同步问题，可以把信号量当作locks 和 condition variable 使用。
 信号量的定义: A semaphore is an object with an integer value that we can manipulate
with two routines; in the POSIX standard, these routines are sem wait()
and sem post()
 #include &lt;semaphore.hsem_t s; sem_init(&amp;s, 0, 1); //第二个参数 0 表示只在单个进程的线程间共享信号量 1 多个进程中间的线程共享信号量 //第三个参数 1 信号量的int value 初始值 semaphore信号量的用法 用之前先确认三点：
 sem_wait() 如果信号量的值&gt;0 先执行-1操作然后立刻return ; 如果信号量的值&lt;=0 就阻塞调用它的线程 sem_post() 不像wait 操作那样需要特定的条件.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-26-common-concurrency-bugs/" class="link black dim">
        常见的并发问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      有研究者通过研究Mysql,Mozilla,Apache,OpenOffice中的关于并发的问题发现，非死锁问题大概是死锁问题数量的两倍
####非死锁问题 只列举一些常见的问题
1. Atomicity Violation 违反原子性 Thread 1:: if (thd-&gt;proc_info) { fputs(thd-&gt;proc_info, ...); } Thread 2:: thd-&gt;proc_info = NULL; 比如当线程1检查完proc_info 的值之后打算往里面写操作的时候，系统中断了线程1，线程2操作proc_info被置NULL;这个过程就违法了原子性操作。
解决方法就是加个pthread_mutex_t锁
2. Order-Violation Bugs 顺序冲突 Thread 1:: void init() { mThread = PR_CreateThread(mMain, ...); } 6 Thread 2:: void mMain(...) { mState = mThread-&gt;State; } 这个就更好理解了，thread2 以为 thread1 已经创建好了线程mThread ，但是有可能没创建好，所以需要condition variable 约束一下
死锁问题 死锁发生的主要原因：
 Mutual exclusion 很难不用mutual exclusion, 或许可以在硬件上找到替代方案 Hold-and-wait fix : 让某个线程一次性获得所有锁 No preemption
fix:设计优先级 Circular wait
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-26-condition-variable/" class="link black dim">
        Condition Variable 条件变量
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Condition Variables 的主要概念 A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired; some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by signaling on the condition). Condition Variable 的两个主要操作
 pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己 pthread_cond_signal() 唤醒等待某个cv的线程  Condition Variables的应用 场景一：Parent Waiting For Child 父线程等待子线程 最容一想到的办法使用一个共享变量shard variable
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-11-locks/" class="link black dim">
        Locks锁
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Locks provide some minimal amount of control over scheduling to programmers.
 线程是程序员创建的，但是由OS安排执行的，怎么执行是OS说了算的，所以这回导致一些超出程序员预想的混乱。 而lock可以帮助程序员减少这些混乱 ，让程序稍微有一点可控制性。线程用的锁的名字是mutex, 它在线程之间提供了一种互斥锁
如果自己创建一个锁 创建一个锁可以很好理解锁是如何工作的。要想组建一个锁（需要OS和硬件支持），1.要想明白这个锁是干什么的（例子用互斥锁 mutual exclusion）,2.正确,，3.是公平，4.是性能
先设定一个最简单的锁的情况：
![image-20190712102200391]({{ site.url }}/assets/img/image-20190712102200391.png)
假设CPU是单核的，一个进程在执行关键代码的时候不会被中断，就好像是获得了锁一样。
好处就是非常简单，坏处就比较多：
 有的线程霸占CPU不释放锁 在多核CPU没用 关闭中断，中断就丢失了，比如硬盘完成了一个读操作，CPU就不知道去唤醒等待读操作的线程 没效率  为了在多核情况下有用，改进一下我们的锁，用一个全局的标志flag ，多核都能访问
![image-20190712103103446]({{ site.url }}/assets/img/image-20190712103103446.png)
我们可以看到lock 函数里面有个test-and-set 操作，这个操作实际上是CPU自带的一个指令。
这个锁有两个问题：一个是正确性 另一个是性能问题
当两个线程同时看到flag=0的时候他们就同时把flag设置成1 以为自己获得了锁，性能问题和之前一样，一个线程获得锁，其他线程就干等，占着CPU资源干等
要解决正确性问题我们就求助硬件了，就要用到CPU的另一个指令就是xchg (x86), 它是一个原子性的test-and-set 操作，不允许两个线程同时执行，用C语言描述一下这个操作
![image-20190712104215636]({{ site.url }}/assets/img/image-20190712104215636.png)
我们记住CPU里面它就是原子性操作，我们的锁就变成了下面的样子
![image-20190712104329019]({{ site.url }}/assets/img/image-20190712104329019.png)
我们评估一下现在的锁，实现了目的互斥锁以及要求的正确，但是还是没解决公平和性能
没有获得锁的线程一直处于test-and-set 操作循环中，所以这种锁也叫spin lock 自旋锁。既然满足了正确性，但是总是要个先后嘛，这个锁要想在单核CPU上正确工作需要抢先调度策略preemptive scheduler
CPU还有一个指令是compare-and-swap
![image-20190712104941718]({{ site.url }}/assets/img/image-20190712104941718.png)
用这个指令来实现锁其实和test-and-set 差别不大
![image-20190712105014816]({{ site.url }}/assets/img/image-20190712105014816.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://example.org/posts/2019-07-06-thread/" class="link black dim">
        线程概述
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      为什么使用线程  并行parallelism的需要 避免程序因为低速的IO操作阻塞 尽管可以用多进程解决一些问题，但是线程可以共享一个内存地址空间，当需要贡献数据的时候线程的选择更自然  线程的问题  共享数据比较难操作 不可控制的执行计划 线程等待其他线程  线程Thread API 1.Thread Creation #include &lt;pthread.h&gt; int pthread_create( pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void*), void * arg); 第一个参数 thread 是结构类型pthread_t 的指针，我们用它来和thread交互，所以需要把它传给pthread_create()来初始化它
第二个参数是是设置线程的属性
第三个线程要执行的function
第四个是第三个参数function的参数
代码
#include &lt;pthread.h&gt; 2typedef struct __myarg_t { int a; int b; } myarg_t; void *mythread(void *arg) { myarg_t *m = (myarg_t *) arg; printf(&#34;%d %d\n&#34;, m-&gt;a, m-&gt;b); return NULL; } int main(int argc, char *argv[]) { pthread_t p; int rc; myarg_t args; args.
    </div>
  </div>
</div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  My New Hugo Site 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
