<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Condition Variable 条件变量 | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Condition Variables 的主要概念 A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired; some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by signaling on the condition). Condition Variable 的两个主要操作
 pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己 pthread_cond_signal() 唤醒等待某个cv的线程  Condition Variables的应用 场景一：Parent Waiting For Child 父线程等待子线程 最容一想到的办法使用一个共享变量shard variable">
    <meta name="generator" content="Hugo 0.74.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Condition Variable 条件变量" />
<meta property="og:description" content="Condition Variables 的主要概念 A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired; some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by signaling on the condition). Condition Variable 的两个主要操作
 pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己 pthread_cond_signal() 唤醒等待某个cv的线程  Condition Variables的应用 场景一：Parent Waiting For Child 父线程等待子线程 最容一想到的办法使用一个共享变量shard variable" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/2019-07-26-condition-variable/" />
<meta property="article:published_time" content="2019-07-26T14:24:00+00:00" />
<meta property="article:modified_time" content="2019-07-26T14:24:00+00:00" />
<meta itemprop="name" content="Condition Variable 条件变量">
<meta itemprop="description" content="Condition Variables 的主要概念 A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired; some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by signaling on the condition). Condition Variable 的两个主要操作
 pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己 pthread_cond_signal() 唤醒等待某个cv的线程  Condition Variables的应用 场景一：Parent Waiting For Child 父线程等待子线程 最容一想到的办法使用一个共享变量shard variable">
<meta itemprop="datePublished" content="2019-07-26T14:24:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-07-26T14:24:00&#43;00:00" />
<meta itemprop="wordCount" content="791">



<meta itemprop="keywords" content="threads,concurrency,OSTEP笔记,condition variable,条件变量," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Condition Variable 条件变量"/>
<meta name="twitter:description" content="Condition Variables 的主要概念 A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired; some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by signaling on the condition). Condition Variable 的两个主要操作
 pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己 pthread_cond_signal() 唤醒等待某个cv的线程  Condition Variables的应用 场景一：Parent Waiting For Child 父线程等待子线程 最容一想到的办法使用一个共享变量shard variable"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://example.org/posts/2019-07-26-condition-variable/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://example.org/posts/2019-07-26-condition-variable/&amp;text=Condition%20Variable%20%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://example.org/posts/2019-07-26-condition-variable/&amp;title=Condition%20Variable%20%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">Condition Variable 条件变量</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-07-26T14:24:00Z">July 26, 2019</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h3 id="condition-variables-的主要概念">Condition Variables 的主要概念</h3>
<p>A condition variable is an explicit queue that threads can put themselves on when some state of execution is not as desired;
some other thread, when it changes said state, can then wake one (or
more) of those waiting threads and thus allow them to continue (by signaling on the condition).
Condition Variable 的两个主要操作</p>
<ol>
<li>pthread_cond_wait() 这个操作会自动释放mutex锁，如果cv条件不满足就block自己</li>
<li>pthread_cond_signal() 唤醒等待某个cv的线程</li>
</ol>
<h3 id="condition-variables的应用">Condition Variables的应用</h3>
<h4 id="场景一parent-waiting-for-child-父线程等待子线程">场景一：Parent Waiting For Child 父线程等待子线程</h4>
<p>最容一想到的办法使用一个共享变量shard variable</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> done <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">child</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    printf(<span style="color:#e6db74">&#34;child</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> NULL;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
    printf(<span style="color:#e6db74">&#34;parent: begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    pthread_t c;
    Pthread_create(<span style="color:#f92672">&amp;</span>c, NULL, child, NULL); <span style="color:#75715e">// create child
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (done <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// spin
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;parent: end</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>但是这种方式会导致父进程spin 而且浪费CPU资源，这种情况下就可以使用condition variable</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//Pthread 大写开头的是书中代码有对pthread原生方法的封装 不影响代码逻辑阅读
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> done <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
pthread_mutex_t m <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c <span style="color:#f92672">=</span> PTHREAD_COND_INITIALIZER;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_exit</span>() {
    Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>m);
    done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    Pthread_cond_signal(<span style="color:#f92672">&amp;</span>c);
    Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>m);
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">child</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    printf(<span style="color:#e6db74">&#34;child</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    thr_exit();
    <span style="color:#66d9ef">return</span> NULL;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">thr_join</span>() {
    Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">while</span> (done <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    	Pthread_cond_wait(<span style="color:#f92672">&amp;</span>c, <span style="color:#f92672">&amp;</span>m);
    Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>m);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
    printf(<span style="color:#e6db74">&#34;parent: begin</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    pthread_t p;
    Pthread_create(<span style="color:#f92672">&amp;</span>p, NULL, child, NULL);
    thr_join();
    printf(<span style="color:#e6db74">&#34;parent: end</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>使用condition variable 搭配状态变量done和锁mutex 是必须的</strong><br>
但是上面情况并不是完美的比如下面的情况：</p>
<blockquote>
<p>当主进程执行 thr_join() 的时候发现done==0,然后打算调用wait 去sleep的时候，主线程被中断，此后子线程执行。当子线程设置done=1和执行 sigin() 操作的时候发现没有在wait的线程，也就没有线程被唤醒了。当主线程再次执行的时候就会一直 wait and sleep forever</p>
</blockquote>
<p>这就是race condition（竞态条件）</p>
<h4 id="场景二the-producerconsumer-or-bounded-buffer-problem">场景二:<strong>the producer/consumer or bounded-buffer problem</strong></h4>
<p>最简单的情况是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//不足和问题：
</span><span style="color:#75715e">//buffer 只保存一个int值
</span><span style="color:#75715e">//buffer 写满的情况下还会继续写  buffer为空的时候还会继续读
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> buffer;
<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// initially, empty
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(<span style="color:#66d9ef">int</span> value) {
    assert(count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    buffer <span style="color:#f92672">=</span> value;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>() {
    assert(count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> buffer;
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">int</span> loops <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) arg;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        put(i);
    }
}
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> get();
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, tmp);
    }
}
</code></pre></div><p>上面的写法太简单且不实用，看一下面的写法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//使用mutex lock 和 condition variable
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> loops; <span style="color:#75715e">// must initialize somewhere...
</span><span style="color:#75715e"></span>cond_t cond;
mutex_t mutex;
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);              <span style="color:#75715e">// p1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)                          <span style="color:#75715e">// p2
</span><span style="color:#75715e"></span>            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex);   <span style="color:#75715e">// p3
</span><span style="color:#75715e"></span>        put(i);                                 <span style="color:#75715e">// p4
</span><span style="color:#75715e"></span>        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>cond);             <span style="color:#75715e">// p5
</span><span style="color:#75715e"></span>        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);           <span style="color:#75715e">// p6
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);             <span style="color:#75715e">// c1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)                         <span style="color:#75715e">// c2
</span><span style="color:#75715e"></span>            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex);   <span style="color:#75715e">// c3
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> get();                        <span style="color:#75715e">// c4
</span><span style="color:#75715e"></span>        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>cond);             <span style="color:#75715e">// c5
</span><span style="color:#75715e"></span>        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);           <span style="color:#75715e">// c6
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, tmp);
    }
}
</code></pre></div><p>上面这种写法在只有一个 producer 和 一个 consumer 的时候是可以的，但是如果有多个 consumer 的就已经不行了为什么这么说看下图 假设 Tc1 and Tc2  是consumer  Tp 是 producer</p>
<p>![1564114256399]({{ site.url }}/assets/img/1564114256399.png)</p>
<p>从上往下看执行顺序，1. Tc1拿到锁去读取buffer的时候发现buffer是空的，于是sleep，释放锁。2.这个时候Tp拿到这个锁， Tp获得锁开始写内容，Tp写完之后打算释放锁且唤醒等待的消费者Tc1（这个时候只有Tc1在等待），但是释放所得瞬间Tc2 拿到了锁, Tc2 执行拿走了Tc1等待的buffer 内容（这个时候buffer有内容，Tc2 不用wait），Tc1醒来的时候发现它的等的东西没了.</p>
<p>简单来说就是： producer 唤醒Tc1和  Tc1开始run的这中间，buffer的状态变了</p>
<p>怎么解决这个问题呢，就是Tc1唤醒的时候再检查一下count==1,具体就是<strong>把if 变成while</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);              <span style="color:#75715e">// p1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)                          <span style="color:#75715e">// p2
</span><span style="color:#75715e"></span>            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex);   <span style="color:#75715e">// p3
</span><span style="color:#75715e"></span>        put(i);                                 <span style="color:#75715e">// p4
</span><span style="color:#75715e"></span>        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>cond);             <span style="color:#75715e">// p5
</span><span style="color:#75715e"></span>        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);           <span style="color:#75715e">// p6
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);             <span style="color:#75715e">// c1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)                         <span style="color:#75715e">// c2
</span><span style="color:#75715e"></span>            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex);   <span style="color:#75715e">// c3
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> get();                        <span style="color:#75715e">// c4
</span><span style="color:#75715e"></span>        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>cond);             <span style="color:#75715e">// c5
</span><span style="color:#75715e"></span>        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);           <span style="color:#75715e">// c6
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, tmp);
    }
}
</code></pre></div><p>解决了这个问题，其实还有另个一问题，看图<br>
![1564118292597]({{ site.url }}/assets/img/1564118292597.png)</p>
<p>这个问题，就是Tc1释放锁之后，Tc2获得了锁，然后两个消费者都sleep了（都执行到c3行代码），然后Tp获得锁往buffer写数据，写完之后唤醒Tc1，自己sleep, 释放锁。Tc1被唤醒获得然后拿走了buffer的数据，然后（c5）唤醒了Tc2, Tc2醒了之后发现没数据又sleep了，然后这三者都sleep了</p>
<p>稍微想一下就知道问题在哪里，Tc1读完数据之后应该唤醒Tp让它继续写数据, 但是我们的condition variable 只有一个,所以Tc2被唤醒了。</p>
<p>所以我们再加一个conditon variable 来区分是唤醒producer  还是  consumer</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">cond_t empty, fill;
mutex_t mutex;
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
        <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>empty, <span style="color:#f92672">&amp;</span>mutex);
        put(i);
        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>fill);
        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
        <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            Pthread_cond_wait(<span style="color:#f92672">&amp;</span>fill, <span style="color:#f92672">&amp;</span>mutex);
        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> get();
        Pthread_cond_signal(<span style="color:#f92672">&amp;</span>empty);
        Pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, tmp);
    }
}
</code></pre></div><p>我们也得出一个原则，消费者consumer不能唤醒消费者，生产者producer也不能唤醒生产者<br>
以上是我们单元素buffer的producer&amp;consumer问题，下面我们看看多元素buffer的情况<br>
正确的姿势:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> max;
<span style="color:#66d9ef">int</span> loops;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>buffer;

<span style="color:#66d9ef">int</span> use_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> fill_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> num_full <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

pthread_cond_t empty <span style="color:#f92672">=</span> PTHREAD_COND_INITIALIZER;
pthread_cond_t fill <span style="color:#f92672">=</span> PTHREAD_COND_INITIALIZER;
pthread_mutex_t m <span style="color:#f92672">=</span> PTHREAD_MUTEX_INITIALIZER;

<span style="color:#66d9ef">int</span> consumers <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">int</span> verbose <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_fill</span>(<span style="color:#66d9ef">int</span> value) {
    buffer[fill_ptr] <span style="color:#f92672">=</span> value;
    fill_ptr <span style="color:#f92672">=</span> (fill_ptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> max;
    num_full<span style="color:#f92672">++</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_get</span>() {
    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> buffer[use_ptr];
    use_ptr <span style="color:#f92672">=</span> (use_ptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> max;
    num_full<span style="color:#f92672">--</span>;
    <span style="color:#66d9ef">return</span> tmp;
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">producer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> loops; i<span style="color:#f92672">++</span>) {
        Mutex_lock(<span style="color:#f92672">&amp;</span>m);            <span style="color:#75715e">// p1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (num_full <span style="color:#f92672">==</span> max)     <span style="color:#75715e">// p2
</span><span style="color:#75715e"></span>            Cond_wait(<span style="color:#f92672">&amp;</span>empty, <span style="color:#f92672">&amp;</span>m); <span style="color:#75715e">// p3
</span><span style="color:#75715e"></span>        do_fill(i);                <span style="color:#75715e">// p4
</span><span style="color:#75715e"></span>        Cond_signal(<span style="color:#f92672">&amp;</span>fill);        <span style="color:#75715e">// p5
</span><span style="color:#75715e"></span>        Mutex_unlock(<span style="color:#f92672">&amp;</span>m);          <span style="color:#75715e">// p6
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// end case: put an end-of-production marker (-1)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// into shared buffer, one per consumer
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> consumers; i<span style="color:#f92672">++</span>) {
        Mutex_lock(<span style="color:#f92672">&amp;</span>m);
        <span style="color:#66d9ef">while</span> (num_full <span style="color:#f92672">==</span> max)
            Cond_wait(<span style="color:#f92672">&amp;</span>empty, <span style="color:#f92672">&amp;</span>m);
        do_fill(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        Cond_signal(<span style="color:#f92672">&amp;</span>fill);
        Mutex_unlock(<span style="color:#f92672">&amp;</span>m);
    }

    <span style="color:#66d9ef">return</span> NULL;
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">consumer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#75715e">// consumer: keep pulling data out of shared buffer
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// until you receive a -1 (end-of-production marker)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (tmp <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        Mutex_lock(<span style="color:#f92672">&amp;</span>m);           <span style="color:#75715e">// c1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (num_full <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)      <span style="color:#75715e">// c2
</span><span style="color:#75715e"></span>            Cond_wait(<span style="color:#f92672">&amp;</span>fill, <span style="color:#f92672">&amp;</span>m); <span style="color:#75715e">// c3
</span><span style="color:#75715e"></span>        tmp <span style="color:#f92672">=</span> do_get();           <span style="color:#75715e">// c4
</span><span style="color:#75715e"></span>        Cond_signal(<span style="color:#f92672">&amp;</span>empty);      <span style="color:#75715e">// c5
</span><span style="color:#75715e"></span>        Mutex_unlock(<span style="color:#f92672">&amp;</span>m);         <span style="color:#75715e">// c6
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> NULL;
}
</code></pre></div><ul class="pa0">
  
   <li class="list">
     <a href="/tags/threads" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">threads</a>
   </li>
  
   <li class="list">
     <a href="/tags/concurrency" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">concurrency</a>
   </li>
  
   <li class="list">
     <a href="/tags/ostep%E7%AC%94%E8%AE%B0" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">OSTEP笔记</a>
   </li>
  
   <li class="list">
     <a href="/tags/condition-variable" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">condition variable</a>
   </li>
  
   <li class="list">
     <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">条件变量</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/2019-07-11-locks/">Locks锁</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/2019-07-06-thread/">线程概述</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  My New Hugo Site 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
